"""
Direct OpenSSL bindings using CFFI for GIL-releasing classical cryptography.

This module provides RSA, ECDSA, and EdDSA implementations that release the GIL
during cryptographic operations, enabling true multi-threaded parallelism similar
to liboqs PQC algorithms.

Note: Type checking errors for 'lib' and 'ffi' are expected - these objects are
dynamically generated by CFFI at runtime and cannot be statically typed.
"""
# pyright: basic
# type: ignore

import base64
from typing import Tuple, Dict, Any
from .base import SignatureAlgorithm

try:
    from cffi import FFI  # type: ignore[import]
    CFFI_AVAILABLE = True
except ImportError:
    CFFI_AVAILABLE = False
    _CFFI_ERROR = "cffi not available - install with: pip install cffi"

# Initialize FFI
if CFFI_AVAILABLE:
    ffi = FFI()  # type: ignore[name-defined]
    
    # Define OpenSSL C API declarations
    ffi.cdef("""
        // Error handling
        unsigned long ERR_get_error(void);
        char *ERR_error_string(unsigned long e, char *buf);
        
        // Memory management
        void *OPENSSL_malloc(size_t num);
        void OPENSSL_free(void *ptr);
        
        // RSA
        typedef struct rsa_st RSA;
        typedef struct bignum_st BIGNUM;
        typedef struct evp_pkey_st EVP_PKEY;
        typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;
        typedef struct evp_md_st EVP_MD;
        typedef struct evp_md_ctx_st EVP_MD_CTX;
        
        RSA *RSA_new(void);
        void RSA_free(RSA *rsa);
        int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, void *cb);
        
        BIGNUM *BN_new(void);
        void BN_free(BIGNUM *bn);
        int BN_set_word(BIGNUM *bn, unsigned long w);
        
        EVP_PKEY *EVP_PKEY_new(void);
        void EVP_PKEY_free(EVP_PKEY *pkey);
        int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, RSA *key);
        RSA *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);
        
        EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, void *e);
        void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);
        int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
        int EVP_PKEY_sign(EVP_PKEY_CTX *ctx, unsigned char *sig, size_t *siglen,
                          const unsigned char *tbs, size_t tbslen);
        int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
        int EVP_PKEY_verify(EVP_PKEY_CTX *ctx, const unsigned char *sig, size_t siglen,
                           const unsigned char *tbs, size_t tbslen);
        int EVP_PKEY_CTX_set_rsa_padding(EVP_PKEY_CTX *ctx, int pad);
        int EVP_PKEY_CTX_set_signature_md(EVP_PKEY_CTX *ctx, const EVP_MD *md);
        
        // Digest
        EVP_MD_CTX *EVP_MD_CTX_new(void);
        void EVP_MD_CTX_free(EVP_MD_CTX *ctx);
        const EVP_MD *EVP_sha256(void);
        int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type, void *impl);
        int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);
        int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);
        
        // DigestSign/DigestVerify (for EdDSA)
        int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx, const EVP_MD *type, void *e, EVP_PKEY *pkey);
        int EVP_DigestSign(EVP_MD_CTX *ctx, unsigned char *sigret, size_t *siglen, const unsigned char *tbs, size_t tbslen);
        int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx, const EVP_MD *type, void *e, EVP_PKEY *pkey);
        int EVP_DigestVerify(EVP_MD_CTX *ctx, const unsigned char *sigret, size_t siglen, const unsigned char *tbs, size_t tbslen);
        
        // EC
        typedef struct ec_key_st EC_KEY;
        typedef struct ec_group_st EC_GROUP;
        
        EC_KEY *EC_KEY_new(void);
        void EC_KEY_free(EC_KEY *key);
        EC_GROUP *EC_GROUP_new_by_curve_name(int nid);
        void EC_GROUP_free(EC_GROUP *group);
        int EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);
        int EC_KEY_generate_key(EC_KEY *key);
        int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, EC_KEY *key);
        EC_KEY *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
        
        // Curve NIDs
        #define NID_X9_62_prime256v1 415
        #define NID_secp384r1 715
        #define NID_secp521r1 716
        
        // RSA padding
        #define RSA_PKCS1_PSS_PADDING 6
        
        // ED25519/ED448
        #define EVP_PKEY_ED25519 1087
        #define EVP_PKEY_ED448 1088
        
        EVP_PKEY *EVP_PKEY_new_raw_private_key(int type, void *e,
                                               const unsigned char *priv, size_t len);
        EVP_PKEY *EVP_PKEY_new_raw_public_key(int type, void *e,
                                              const unsigned char *pub, size_t len);
        int EVP_PKEY_get_raw_private_key(EVP_PKEY *pkey, unsigned char *priv, size_t *len);
        int EVP_PKEY_get_raw_public_key(EVP_PKEY *pkey, unsigned char *pub, size_t *len);
        
        // Key generation for ED25519/ED448
        EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, void *e);
        int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
        int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
        
        // Serialization
        typedef struct bio_st BIO;
        typedef struct bio_method_st BIO_METHOD;
        
        BIO *BIO_new(const BIO_METHOD *type);
        int BIO_free(BIO *a);
        const BIO_METHOD *BIO_s_mem(void);
        int BIO_read(BIO *b, void *data, int len);
        int BIO_write(BIO *b, const void *data, int len);
        long BIO_ctrl(BIO *bp, int cmd, long larg, void *parg);
        
        int i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa);
        int i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa);
        RSA *d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa);
        RSA *d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa);
        
        // PEM RSA functions
        RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, void *cb, void *u);
        RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x, void *cb, void *u);
        
        int i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey);
        int i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey);
        EC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey);
        EC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey);
        
        // PEM EC functions
        EC_KEY *PEM_read_bio_EC_PUBKEY(BIO *bp, EC_KEY **x, void *cb, void *u);
        EC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **x, void *cb, void *u);
        
        #define BIO_CTRL_INFO 3
    """)
    
    # Load OpenSSL library
    try:
        # Try different library names
        lib: Any = None  # type: ignore - CFFI dynamically loads library attributes
        for libname in ['ssl', 'libssl.3', 'libssl.1.1', 'crypto', 'libcrypto.3', 'libcrypto.1.1']:
            try:
                lib = ffi.dlopen(libname)
                break
            except OSError:
                continue
        
        if lib is None:
            CFFI_AVAILABLE = False
            _CFFI_ERROR = "OpenSSL library not found"
    except Exception as e:
        CFFI_AVAILABLE = False
        _CFFI_ERROR = f"Failed to load OpenSSL: {e}"
else:
    lib = None  # type: ignore
    ffi = None  # type: ignore


class RSASignatureOpenSSL(SignatureAlgorithm):
    """RSA signature using direct OpenSSL calls with GIL release."""
    
    def __init__(self, name: str, security_level: str, key_size: int):
        if not CFFI_AVAILABLE:
            raise RuntimeError(f"CFFI/OpenSSL not available: {_CFFI_ERROR}")
        
        super().__init__(name, security_level)
        self.key_size = key_size
        self._pkey = None
        self._rsa = None
    
    def generate_keypair(self) -> Tuple[bytes, bytes]:
        """Generate RSA keypair using OpenSSL."""
        # Create RSA structure
        self._rsa = lib.RSA_new()
        if self._rsa == ffi.NULL:
            raise RuntimeError("Failed to create RSA structure")
        
        # Create BIGNUM for exponent (65537)
        e = lib.BN_new()
        lib.BN_set_word(e, 65537)
        
        # Generate key (this releases GIL in OpenSSL 3.0+)
        ret = lib.RSA_generate_key_ex(self._rsa, self.key_size, e, ffi.NULL)
        lib.BN_free(e)
        
        if ret != 1:
            lib.RSA_free(self._rsa)
            raise RuntimeError("Failed to generate RSA key")
        
        # Wrap in EVP_PKEY
        self._pkey = lib.EVP_PKEY_new()
        lib.EVP_PKEY_set1_RSA(self._pkey, self._rsa)
        
        # Serialize keys
        public_key = self._serialize_rsa_public(self._rsa)
        private_key = self._serialize_rsa_private(self._rsa)
        
        self._public_key = public_key
        self._private_key = private_key
        
        return public_key, private_key
    
    def sign(self, message: bytes) -> bytes:
        """Sign message (GIL-releasing operation)."""
        if self._pkey is None:
            if self._private_key is None:
                raise ValueError("No keypair loaded")
            self._deserialize_private_key()
        
        # Hash message first
        digest = self._hash_sha256(message)
        
        # Create signing context
        ctx = lib.EVP_PKEY_CTX_new(self._pkey, ffi.NULL)
        if ctx == ffi.NULL:
            raise RuntimeError("Failed to create EVP_PKEY_CTX")
        
        try:
            # Initialize signing
            if lib.EVP_PKEY_sign_init(ctx) != 1:
                raise RuntimeError("Failed to init signing")
            
            # Set PSS padding
            lib.EVP_PKEY_CTX_set_rsa_padding(ctx, lib.RSA_PKCS1_PSS_PADDING)
            lib.EVP_PKEY_CTX_set_signature_md(ctx, lib.EVP_sha256())
            
            # Get signature length
            siglen = ffi.new("size_t *")
            if lib.EVP_PKEY_sign(ctx, ffi.NULL, siglen, digest, len(digest)) != 1:
                raise RuntimeError("Failed to get signature length")
            
            # Allocate buffer and sign
            sig = ffi.new("unsigned char[]", siglen[0])
            # This is where GIL is released during the actual signing operation
            if lib.EVP_PKEY_sign(ctx, sig, siglen, digest, len(digest)) != 1:
                raise RuntimeError("Failed to sign")
            
            return bytes(ffi.buffer(sig, siglen[0]))
        finally:
            lib.EVP_PKEY_CTX_free(ctx)
    
    def verify(self, message: bytes, signature: bytes) -> bool:
        """Verify signature (GIL-releasing operation)."""
        if self._pkey is None:
            if self._public_key is None:
                raise ValueError("No public key loaded")
            self._deserialize_public_key()
        
        # Hash message
        digest = self._hash_sha256(message)
        
        # Create verification context
        ctx = lib.EVP_PKEY_CTX_new(self._pkey, ffi.NULL)
        if ctx == ffi.NULL:
            raise RuntimeError("Failed to create EVP_PKEY_CTX")
        
        try:
            if lib.EVP_PKEY_verify_init(ctx) != 1:
                raise RuntimeError("Failed to init verify")
            
            lib.EVP_PKEY_CTX_set_rsa_padding(ctx, lib.RSA_PKCS1_PSS_PADDING)
            lib.EVP_PKEY_CTX_set_signature_md(ctx, lib.EVP_sha256())
            
            # Verify (GIL released here)
            ret = lib.EVP_PKEY_verify(ctx, signature, len(signature), digest, len(digest))
            return ret == 1
        finally:
            lib.EVP_PKEY_CTX_free(ctx)
    
    def get_sizes(self) -> Dict[str, int]:
        if self._public_key is None or self._private_key is None:
            self.generate_keypair()
        
        test_sig = self.sign(b"test" * 8)
        return {
            'public_key': len(self._public_key),
            'private_key': len(self._private_key),
            'signature': len(test_sig)
        }
    
    def _hash_sha256(self, data: bytes) -> bytes:
        """Hash data with SHA-256."""
        ctx = lib.EVP_MD_CTX_new()
        lib.EVP_DigestInit_ex(ctx, lib.EVP_sha256(), ffi.NULL)
        lib.EVP_DigestUpdate(ctx, data, len(data))
        
        md = ffi.new("unsigned char[]", 32)
        md_len = ffi.new("unsigned int *")
        lib.EVP_DigestFinal_ex(ctx, md, md_len)
        lib.EVP_MD_CTX_free(ctx)
        
        return bytes(ffi.buffer(md, md_len[0]))
    
    def _serialize_rsa_public(self, rsa) -> bytes:
        bio = lib.BIO_new(lib.BIO_s_mem())
        lib.i2d_RSA_PUBKEY_bio(bio, rsa)
        
        data_ptr = ffi.new("char **")
        length = lib.BIO_ctrl(bio, 3, 0, data_ptr)  # BIO_CTRL_INFO = 3
        result = bytes(ffi.buffer(data_ptr[0], length))
        lib.BIO_free(bio)
        return result
    
    def _serialize_rsa_private(self, rsa) -> bytes:
        bio = lib.BIO_new(lib.BIO_s_mem())
        lib.i2d_RSAPrivateKey_bio(bio, rsa)
        
        data_ptr = ffi.new("char **")
        length = lib.BIO_ctrl(bio, 3, 0, data_ptr)  # BIO_CTRL_INFO = 3
        result = bytes(ffi.buffer(data_ptr[0], length))
        lib.BIO_free(bio)
        return result
    
    def _deserialize_public_key(self):
        bio = lib.BIO_new(lib.BIO_s_mem())
        # Cached keys are base64-encoded DER bytes
        if isinstance(self._public_key, str):
            key_bytes = base64.b64decode(self._public_key)
        else:
            key_bytes = self._public_key
        lib.BIO_write(bio, key_bytes, len(key_bytes))
        self._rsa = lib.d2i_RSA_PUBKEY_bio(bio, ffi.NULL)
        lib.BIO_free(bio)
        
        self._pkey = lib.EVP_PKEY_new()
        lib.EVP_PKEY_set1_RSA(self._pkey, self._rsa)
    
    def _deserialize_private_key(self):
        bio = lib.BIO_new(lib.BIO_s_mem())
        # Cached keys are base64-encoded DER bytes
        if isinstance(self._private_key, str):
            key_bytes = base64.b64decode(self._private_key)
        else:
            key_bytes = self._private_key
        lib.BIO_write(bio, key_bytes, len(key_bytes))
        self._rsa = lib.d2i_RSAPrivateKey_bio(bio, ffi.NULL)
        lib.BIO_free(bio)
        
        self._pkey = lib.EVP_PKEY_new()
        lib.EVP_PKEY_set1_RSA(self._pkey, self._rsa)
    
    def __del__(self):
        # Clean up OpenSSL objects to prevent memory leaks
        if lib and ffi:
            if self._pkey is not None and self._pkey != ffi.NULL:
                lib.EVP_PKEY_free(self._pkey)
                self._pkey = None
            if self._rsa is not None and self._rsa != ffi.NULL:
                lib.RSA_free(self._rsa)
                self._rsa = None


class ECDSASignatureOpenSSL(SignatureAlgorithm):
    """ECDSA signature using direct OpenSSL calls with GIL release."""
    
    CURVE_MAP = {
        'secp256r1': 415,  # NID_X9_62_prime256v1
        'secp384r1': 715,  # NID_secp384r1
        'secp521r1': 716,  # NID_secp521r1
    }
    
    def __init__(self, name: str, security_level: str, curve_name: str):
        if not CFFI_AVAILABLE:
            raise RuntimeError(f"CFFI/OpenSSL not available: {_CFFI_ERROR}")
        
        super().__init__(name, security_level)
        self.curve_name = curve_name
        self.curve_nid = self.CURVE_MAP[curve_name]
        self._pkey = None
        self._ec_key = None
    
    def generate_keypair(self) -> Tuple[bytes, bytes]:
        """Generate ECDSA keypair."""
        # Create EC_KEY
        self._ec_key = lib.EC_KEY_new()
        group = lib.EC_GROUP_new_by_curve_name(self.curve_nid)
        lib.EC_KEY_set_group(self._ec_key, group)
        lib.EC_GROUP_free(group)
        
        # Generate key
        if lib.EC_KEY_generate_key(self._ec_key) != 1:
            lib.EC_KEY_free(self._ec_key)
            raise RuntimeError("Failed to generate EC key")
        
        # Wrap in EVP_PKEY
        self._pkey = lib.EVP_PKEY_new()
        lib.EVP_PKEY_set1_EC_KEY(self._pkey, self._ec_key)
        
        # Serialize
        public_key = self._serialize_ec_public(self._ec_key)
        private_key = self._serialize_ec_private(self._ec_key)
        
        self._public_key = public_key
        self._private_key = private_key
        
        return public_key, private_key
    
    def sign(self, message: bytes) -> bytes:
        """Sign message (GIL-releasing).
        
        Uses EVP_DigestSign API which combines hashing and signing into a single
        operation, minimizing GIL-holding operations and context switches.
        """
        if self._pkey is None:
            if self._private_key is None:
                raise ValueError("No keypair loaded")
            self._deserialize_private_key()
        
        # Use DigestSign API for better performance (single atomic operation)
        md_ctx = lib.EVP_MD_CTX_new()
        if md_ctx == ffi.NULL:
            raise RuntimeError("Failed to create MD context")
        
        try:
            # Initialize digest signing with SHA256
            if lib.EVP_DigestSignInit(md_ctx, ffi.NULL, lib.EVP_sha256(), ffi.NULL, self._pkey) != 1:
                raise RuntimeError("Failed to initialize digest signing")
            
            # Get signature length
            siglen = ffi.new("size_t *")
            if lib.EVP_DigestSign(md_ctx, ffi.NULL, siglen, message, len(message)) != 1:
                raise RuntimeError("Failed to get signature length")
            
            # Create signature (GIL released during actual signing)
            sig = ffi.new("unsigned char[]", siglen[0])
            if lib.EVP_DigestSign(md_ctx, sig, siglen, message, len(message)) != 1:
                raise RuntimeError("Failed to create signature")
            
            return bytes(ffi.buffer(sig, siglen[0]))
        finally:
            lib.EVP_MD_CTX_free(md_ctx)
    
    def verify(self, message: bytes, signature: bytes) -> bool:
        """Verify signature (GIL-releasing).
        
        Uses EVP_DigestVerify API which combines hashing and verification into
        a single operation for better multi-threaded performance.
        """
        if self._pkey is None:
            if self._public_key is None:
                raise ValueError("No public key loaded")
            self._deserialize_public_key()
        
        # Use DigestVerify API for better performance
        md_ctx = lib.EVP_MD_CTX_new()
        if md_ctx == ffi.NULL:
            raise RuntimeError("Failed to create MD context")
        
        try:
            # Initialize digest verification with SHA256
            if lib.EVP_DigestVerifyInit(md_ctx, ffi.NULL, lib.EVP_sha256(), ffi.NULL, self._pkey) != 1:
                return False
            
            # Verify signature (GIL released during actual verification)
            ret = lib.EVP_DigestVerify(md_ctx, signature, len(signature), message, len(message))
            return ret == 1
        finally:
            lib.EVP_MD_CTX_free(md_ctx)
    
    def get_sizes(self) -> Dict[str, int]:
        if self._public_key is None or self._private_key is None:
            self.generate_keypair()
        
        test_sig = self.sign(b"test" * 8)
        return {
            'public_key': len(self._public_key),
            'private_key': len(self._private_key),
            'signature': len(test_sig)
        }
    
    def _hash_sha256(self, data: bytes) -> bytes:
        ctx = lib.EVP_MD_CTX_new()
        lib.EVP_DigestInit_ex(ctx, lib.EVP_sha256(), ffi.NULL)
        lib.EVP_DigestUpdate(ctx, data, len(data))
        
        md = ffi.new("unsigned char[]", 32)
        md_len = ffi.new("unsigned int *")
        lib.EVP_DigestFinal_ex(ctx, md, md_len)
        lib.EVP_MD_CTX_free(ctx)
        
        return bytes(ffi.buffer(md, md_len[0]))
    
    def _serialize_ec_public(self, ec_key) -> bytes:
        bio = lib.BIO_new(lib.BIO_s_mem())
        lib.i2d_EC_PUBKEY_bio(bio, ec_key)
        
        data_ptr = ffi.new("char **")
        length = lib.BIO_ctrl(bio, 3, 0, data_ptr)  # BIO_CTRL_INFO = 3
        result = bytes(ffi.buffer(data_ptr[0], length))
        lib.BIO_free(bio)
        return result
    
    def _serialize_ec_private(self, ec_key) -> bytes:
        bio = lib.BIO_new(lib.BIO_s_mem())
        lib.i2d_ECPrivateKey_bio(bio, ec_key)
        
        data_ptr = ffi.new("char **")
        length = lib.BIO_ctrl(bio, 3, 0, data_ptr)  # BIO_CTRL_INFO = 3
        result = bytes(ffi.buffer(data_ptr[0], length))
        lib.BIO_free(bio)
        return result
    
    def _deserialize_public_key(self):
        bio = lib.BIO_new(lib.BIO_s_mem())
        # Cached keys are base64-encoded DER bytes
        if isinstance(self._public_key, str):
            key_bytes = base64.b64decode(self._public_key)
        else:
            key_bytes = self._public_key
        lib.BIO_write(bio, key_bytes, len(key_bytes))
        self._ec_key = lib.d2i_EC_PUBKEY_bio(bio, ffi.NULL)
        lib.BIO_free(bio)
        
        self._pkey = lib.EVP_PKEY_new()
        lib.EVP_PKEY_set1_EC_KEY(self._pkey, self._ec_key)
    
    def _deserialize_private_key(self):
        bio = lib.BIO_new(lib.BIO_s_mem())
        # Cached keys are base64-encoded DER bytes
        if isinstance(self._private_key, str):
            key_bytes = base64.b64decode(self._private_key)
        else:
            key_bytes = self._private_key
        lib.BIO_write(bio, key_bytes, len(key_bytes))
        self._ec_key = lib.d2i_ECPrivateKey_bio(bio, ffi.NULL)
        lib.BIO_free(bio)
        
        self._pkey = lib.EVP_PKEY_new()
        lib.EVP_PKEY_set1_EC_KEY(self._pkey, self._ec_key)
    
    def __del__(self):
        # Clean up OpenSSL objects to prevent memory leaks
        if lib and ffi:
            if self._pkey is not None and self._pkey != ffi.NULL:
                lib.EVP_PKEY_free(self._pkey)
                self._pkey = None
            if self._ec_key is not None and self._ec_key != ffi.NULL:
                lib.EC_KEY_free(self._ec_key)
                self._ec_key = None


class EdDSASignatureOpenSSL(SignatureAlgorithm):
    """EdDSA signature using direct OpenSSL calls with GIL release."""
    
    CURVE_MAP = {
        'ed25519': 1087,  # EVP_PKEY_ED25519
        'ed448': 1088,    # EVP_PKEY_ED448
    }
    
    KEY_SIZES = {
        'ed25519': 32,
        'ed448': 57,
    }
    
    def __init__(self, name: str, security_level: str, curve_name: str):
        if not CFFI_AVAILABLE:
            raise RuntimeError(f"CFFI/OpenSSL not available: {_CFFI_ERROR}")
        
        super().__init__(name, security_level)
        self.curve_name = curve_name
        self.pkey_type = self.CURVE_MAP[curve_name]
        self.key_size = self.KEY_SIZES[curve_name]
        self._pkey = None
    
    def generate_keypair(self) -> Tuple[bytes, bytes]:
        """Generate EdDSA keypair."""
        ctx = lib.EVP_PKEY_CTX_new_id(self.pkey_type, ffi.NULL)
        if ctx == ffi.NULL:
            raise RuntimeError("Failed to create context")
        
        try:
            if lib.EVP_PKEY_keygen_init(ctx) != 1:
                raise RuntimeError("Failed to init keygen")
            
            pkey_ptr = ffi.new("EVP_PKEY **")
            if lib.EVP_PKEY_keygen(ctx, pkey_ptr) != 1:
                raise RuntimeError("Failed to generate key")
            
            self._pkey = pkey_ptr[0]
        finally:
            lib.EVP_PKEY_CTX_free(ctx)
        
        # Extract raw keys
        priv_len = ffi.new("size_t *", self.key_size)
        priv = ffi.new("unsigned char[]", self.key_size)
        lib.EVP_PKEY_get_raw_private_key(self._pkey, priv, priv_len)
        private_key = bytes(ffi.buffer(priv, priv_len[0]))
        
        pub_len = ffi.new("size_t *", self.key_size)
        pub = ffi.new("unsigned char[]", self.key_size)
        lib.EVP_PKEY_get_raw_public_key(self._pkey, pub, pub_len)
        public_key = bytes(ffi.buffer(pub, pub_len[0]))
        
        self._public_key = public_key
        self._private_key = private_key
        
        return public_key, private_key
    
    def sign(self, message: bytes) -> bytes:
        """Sign message (GIL-releasing).
        
        EdDSA uses one-shot signing (EVP_DigestSign) instead of EVP_PKEY_sign.
        """
        if self._pkey is None:
            if self._private_key is None:
                raise ValueError("No keypair loaded")
            # Load private key (this will contain the public key too)
            # EdDSA keys are stored as base64-encoded raw bytes
            if isinstance(self._private_key, str):
                key_bytes = base64.b64decode(self._private_key)
            else:
                key_bytes = self._private_key
            self._pkey = lib.EVP_PKEY_new_raw_private_key(
                self.pkey_type, ffi.NULL, key_bytes, len(key_bytes)
            )
            if self._pkey == ffi.NULL:
                raise RuntimeError("Failed to load private key")
        
        # EdDSA uses DigestSign API (one-shot, no separate init/update/final)
        ctx = lib.EVP_MD_CTX_new()
        if ctx == ffi.NULL:
            raise RuntimeError("Failed to create context")
            
        try:
            # Initialize with NULL digest (EdDSA doesn't use separate hash)
            if lib.EVP_DigestSignInit(ctx, ffi.NULL, ffi.NULL, ffi.NULL, self._pkey) != 1:
                raise RuntimeError("Failed to initialize signing")
            
            # Get signature length
            siglen = ffi.new("size_t *")
            if lib.EVP_DigestSign(ctx, ffi.NULL, siglen, message, len(message)) != 1:
                raise RuntimeError("Failed to get signature length")
            
            # Create signature
            sig = ffi.new("unsigned char[]", siglen[0])
            if lib.EVP_DigestSign(ctx, sig, siglen, message, len(message)) != 1:
                raise RuntimeError("Failed to create signature")
            
            return bytes(ffi.buffer(sig, siglen[0]))
        finally:
            lib.EVP_MD_CTX_free(ctx)
    
    def verify(self, message: bytes, signature: bytes) -> bool:
        """Verify signature (GIL-releasing).
        
        EdDSA uses one-shot verification (EVP_DigestVerify).
        """
        if self._pkey is None:
            if self._public_key is None:
                raise ValueError("No public key loaded")
            # Load public key
            # EdDSA keys are stored as base64-encoded raw bytes
            if isinstance(self._public_key, str):
                key_bytes = base64.b64decode(self._public_key)
            else:
                key_bytes = self._public_key
            self._pkey = lib.EVP_PKEY_new_raw_public_key(
                self.pkey_type, ffi.NULL, key_bytes, len(key_bytes)
            )
            if self._pkey == ffi.NULL:
                raise RuntimeError("Failed to load public key")
        
        ctx = lib.EVP_MD_CTX_new()
        if ctx == ffi.NULL:
            raise RuntimeError("Failed to create context")
            
        try:
            # Initialize with NULL digest (EdDSA doesn't use separate hash)
            if lib.EVP_DigestVerifyInit(ctx, ffi.NULL, ffi.NULL, ffi.NULL, self._pkey) != 1:
                return False
            
            # Verify signature
            ret = lib.EVP_DigestVerify(ctx, signature, len(signature), message, len(message))
            return ret == 1
        finally:
            lib.EVP_MD_CTX_free(ctx)
    
    def get_sizes(self) -> Dict[str, int]:
        if self._public_key is None or self._private_key is None:
            self.generate_keypair()
        
        test_sig = self.sign(b"test" * 8)
        return {
            'public_key': len(self._public_key),
            'private_key': len(self._private_key),
            'signature': len(test_sig)
        }
    
    def __del__(self):
        # Clean up OpenSSL objects to prevent memory leaks
        if lib and ffi:
            if self._pkey is not None and self._pkey != ffi.NULL:
                lib.EVP_PKEY_free(self._pkey)
                self._pkey = None
